# 22. this

## this 키워드

> 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.

`객체`는 상태를 프로퍼티와 동작을 타내는 프로퍼티 동작을 나타내는 메서드를 하나의 논리적인 단위로 묶은 복합구조

```jsx
const circle = {
  // 프로퍼티 : 객체 고유의 상태 데이터
  radius: 5,
  // 메서드 : 상태 데이터를 참조하고 조작하는 동작
  getDiamter() {
    return 2 * circle.radius;
  },
};

console.log(circle.getDiameter()); // 10
```

- getDiameter 메서드 내에서 자신이 속한 객체를 가리키는 식별자 circle을 참조하고 있다. 이 참조 표현식이 평가되는 시점은 메서드가 호출되어 함수 몸체가 실행되는 시점.

자기 자신이 속한 객체를 재귀적으로 참조하는 방식은 일반적이지 않으며 바람직하지도 않다.

`this`는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 `자기 참조 변수`다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다. `암묵적 생성`, 어디서든 참조, `지역변수` 처럼 사용 할 수 있다. 단, this가 가리키는 값, 즉 this바인딩은 함수 호출 방식에 의해 동적으로 결정된다.

```
this 바인딩
바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예로 변수 선언은 변수 이름(식별자)과 확보된 공간의 주소를 바인딩하는 것이다.
this바인딩은 this(키워드로 분류되지만 식별자 역할을 한다.)와 this가 가리킬 객체를 바인딩하는 것이다.
```

## 함수 호출 방식과 this 바인딩

> !! this 바인딩 : 함수 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다!!!!

- 렛시컬 스코프와 this 바인딩은 결정 시기가 다르다.
  함수의 상위 스코프를 결정하는 방식인 `렉시컬 스코프`는 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프를 결정한다. 하지만 this바인딩은 함수 호출 시점에 결정된다.

### 함수를 호출하는 방식

1. 일반 함수 호출
2. 메서드 호출
3. 생성자 함수 호출
4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출

### 일반 함수 호출

> 기본적으로 `this`에는 `전역 객체`가 바인딩 된다.

```jsx
function foo() {
  console.log("이마요시 쇼이치는:", this); // window
  function bar() {
    console.log("쿠로코 테츠야는: ", this); // window
  }
  bar();
}
foo();
```

- `strict mode`가 적용된 일반 함수 내부의 `this`에는 `undefined`가 바인딩 된다.
- 메서드 내에서 정의한 중첩 함수도 일반함수로 호출되면 중첩 내부의 this에는 전역 객체가 바인딩.

```
setTimeout 함수

두 번째 인수로 전달한 시간(ms)만큼 대기한 다음, 첫 번째 인수로 전달한 콜백 함수를 호출하는 타이머 함수다.
22-10 예제에서는 100ms를 대기한 다음, 콜백함수를 호출한다.
setTimeout 함수에 대해서는 41장 "타이머"에서 자세히 살펴볼것이긔☆
```

##### 이처럼 일반 함수로 호출된 모든 함수 (중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩 된다.

외부 함수인 메서드와 중첩 함수 콜백 함수의 this가 일치하지 않는다는 것은 중첩 함수 또는 콜백 함수를 `헬퍼 함수`로 동작하기 어렵게 만든다.
자바스크립트는 `this`를 명시적으로 바인딩할 수 있 는 메서드를 제공한다.
`화살표 함수`를 사용해서 this 바인딩을 일치시킬 수도 있다.

### 메서드 호출

> 메서드 내부의 `this`에는 메서드를 호출한 객체, 즉 메서드를 호출할 때 메서드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체가 바인딩 된다.
> 주의할 것은 메서드 내부의 this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩된다는 것이다.

- 예제 22-14 참조
- 메서드는 객체에 포함된 것이 아니라 독립적으로 존재하는 별도의 객체다.
- 메서드 내부의 `this`는 자신을 호출한 객체를 가리킨다. this에 바인딩 될 객체는 호출 시점에 결정된다.
- 프로토타입 메서드 내부에서 사용된 `this`도 일반 메서드와 마찬가지로 해당 메서드를 호출한 객체에 바인딩.

### 생성자 함수 호출

> 생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩 된다.
> `apply`,`call`,`bind` 메서드는 `Function.prototype`의 메서드다. 즉, 이들 메서드는 모든 함수가 상속받아 사용 가능.

```jsx
// 주어진 this 바인딩과 인수 리스트 배열을 사용하여 함수를 호출
// apply와 call 메서드 사용법

@param thisArg - this로 사용할 객체
@param argsArray - 함수에게 전달할 인수 리스트의 배열 또는 유사 배열 객체
@retruns 호출된 함수의 반환 값

Function.prototype.apply(thisArg[, argsArray])

// 주어진 this 바인딩과 , 로 구분된 인수 리스트를 사용하여 함수 호출
@param thisArg - this로 사용할 객체
@param arg1, arg2, ... - 함수에게 전달할 인수 리스트
@retruns 호출된 함수의 반환값

Function.prototype.call (thisArg[, arg1[, arg2, [, ...]]])
```

- `apply`와 `call`메서드의 본질적인 기능은 함수를 호출하는 것이다.
- 위 대표 용도 `arguments` 객체와 같은 유사 배열 객체에 배열 메서드를 사용 하는 경우
  - Array.prototype.slice.call를 인수 없이 호출하면 배열의 복사본 생성.
- 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치 하는 문제를 해결

<details>
<summary>apply</summary>
apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달
</details>

<details>
<summary>call</summary>
call 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달
</details>

<details>
<summary>Function.prototype.bind</summary>
`apply`와 `call`메서드와 달리 함수를 호출하지 않는다.
다만 첫 번째 인수로 전달한 this 바인딩이 교체된 함수를 새롭게 생성해 반환.
bind 메서드는 함수를 호출하지는 않으므로 명시적으로 호출.

콜백함수 내부의 this외부 함수의 this와 일치시키는 방법 = bind 메서드를 사용하기

- 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치 하는 문제를 해결
</details>

```jsx
// 예제 22-23
const person2 = {
  name: "카가미",
  foo(callback) {
    // 1 = 호출되기 이전 person 객체를 가리킴
    setTimeout(callback, 100);
  },
};

person.foo(function () {
  console.log(`${this.name}상 전 처음부터 여기 있었는데요.`); // 2 = 콜백 호출함. 전역 객체를 가리킴
  /*
    일반 함수로 호출된 콜백 함수 내부의 this.name은 브라우저 환경에서 window.name 과 같음
    브라우저 환경에서 window.name은 창의 이름을 나타내는 빌트인 프로퍼티이며 기본값은 ``이다.
    node.js 환경에서 this.name은 undefined임...
    */
});

// 예제 22-24
// 콜백함수 내부의 this외부 함수의 this와 일치시키는 방법 = bind 메서드를 사용하기
const person3 = {
  name: "카가미",
  foo(callback) {
    // bind 메서드로 callback 함수 내부의 this 바인딩을 전달
    setTimeout(callback.bind(this), 100);
  },
};

person.foo(function () {
  console.log(`${this.name}상 전 처음부터 여기 있었는데요.`); // 2 = 콜백 호출함. 전역 객체를 가리킴
});
```

### 정리

> 지금까지 함수 호출 방식에 따라 `this 바인딩`이 동적으로 결정되는 것에 대해 살펴보았다.

| 함수 호출 방식                                             | this 바인딩                                                            |
| ---------------------------------------------------------- | ---------------------------------------------------------------------- |
| 일반 함수 호출                                             | 전역 객체                                                              |
| 메서드 호출                                                | 메서드를 호출한 객체                                                   |
| 생성자 함수 호출                                           | 생성자가 (미래에) 생성할 인스턴스                                      |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 첫 번째 인수로 전달한 객체 |
